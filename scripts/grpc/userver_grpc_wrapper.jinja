/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */
/* This file was generated from {{ proto.source_file }} */
#pragma once

{% for include in proto.includes %}
#include {{include}}
{% endfor %}

namespace {{ proto.namespace }} {

{% for service in proto.services %}
// Client for {{service.name}}
class {{service.name}}Client : public ::clients::grpc::ServiceClient<{{service.name}}> {
 public:
  using ::clients::grpc::ServiceClient<{{service.name}}>::ServiceClient;

  {% for method in service.method %}
  {% if method.client_streaming and method.server_streaming %}
  // Bidirectional stream type for {{method.name}} method
  using {{method.name}}StreamType =
        ::clients::grpc::BidirStream<
            {{ method.input_type | grpc_to_cpp_name }},
            {{ method.output_type | grpc_to_cpp_name }}>;
  {% elif method.client_streaming %}
  // Client->server output stream type for {{method.name}} method
  using {{method.name}}StreamType =
        ::clients::grpc::OutputStream<
            {{ method.input_type | grpc_to_cpp_name }},
            {{ method.output_type | grpc_to_cpp_name }}>;
  {% elif method.client_streaming %}
  // Server->client input stream type for {{method.name}} method
  using {{method.name}}StreamType =
        ::clients::grpc::InputStream<
            {{ method.output_type | grpc_to_cpp_name }}>;
  {% endif %}
  auto {{method.name}}(
      {% if not method.client_streaming %}
      const {{ method.input_type | grpc_to_cpp_name }}& request,
      {% endif %}
      ::std::shared_ptr<::grpc::ClientContext> context =
          ::std::make_shared<::grpc::ClientContext>()) {
    {% if not method.client_streaming and not method.server_streaming %}
    auto future = Prepare(&StubType::PrepareAsync{{method.name}}, std::move(context),
                          request, "{{service.name}}::{{method.name}}");
    return future.get();
    {% elif not method.client_streaming %}
    return Prepare(&StubType::PrepareAsync{{method.name}}, std::move(context),
                   request, "{{service.name}}::{{method.name}}");
    {% else %}
    return Prepare(&StubType::PrepareAsync{{method.name}}, std::move(context),
                   "{{service.name}}::{{method.name}}");
    {% endif %}
  }
  {% endfor %}
};
{% endfor %}

}  // namespace {{ proto.namespace }}
