/* THIS FILE IS AUTOGENERATED, DON'T EDIT! */
/* This file was generated from {{ proto.source_file }} */
#pragma once

{% for include in proto.includes %}
#include {{include}}
{% endfor %}

namespace {{ proto.namespace }} {

{% for service in proto.services %}
// Client for {{service.name}}
class {{service.name}}Client : public ::clients::grpc::ServiceClient<{{service.name}}> {
 public:
  using ::clients::grpc::ServiceClient<{{service.name}}>::ServiceClient;

  {% for method in service.method %}
  {% if method.client_streaming and method.server_streaming %}
  // Bidirectional stream type for {{method.name}} method
  using {{method.name}}StreamType =
        ::clients::grpc::BidirStream<
            {{ method.input_type | grpc_to_cpp_name }},
            {{ method.output_type | grpc_to_cpp_name }}>;
  {% elif method.client_streaming %}
  // Client->server output stream type for {{method.name}} method
  using {{method.name}}StreamType =
        ::clients::grpc::OutputStream<
            {{ method.input_type | grpc_to_cpp_name }},
            {{ method.output_type | grpc_to_cpp_name }}>;
  {% elif method.client_streaming %}
  // Server->client input stream type for {{method.name}} method
  using {{method.name}}StreamType =
        ::clients::grpc::InputStream<
            {{ method.output_type | grpc_to_cpp_name }}>;
  {% endif %}
  auto {{method.name}}({% if not method.client_streaming %}const {{ method.input_type | grpc_to_cpp_name }}& request{% endif %}) {
    {% if not method.client_streaming and not method.server_streaming %}
    auto future = Prepare(&StubType::PrepareAsync{{method.name}}, request);
    return future.Get();
    {% elif not method.client_streaming %}
    return Prepare(&StubType::PrepareAsync{{method.name}}, request);
    {% else %}
    return Prepare(&StubType::PrepareAsync{{method.name}});
    {% endif %}
  }
  {% endfor %}
};
{% endfor %}

}  // namespace {{ proto.namespace }}
