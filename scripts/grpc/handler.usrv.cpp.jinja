{% import "utils.inc.jinja" as utils %}
{{- utils.do_not_edit() }}
// This file was generated from {{ proto.source_file }}
#include "{{ proto.source_file_without_ext }}_handler.usrv.pb.hpp"

#include <userver/ugrpc/server/impl/listen_async.hpp>
#include <userver/ugrpc/server/impl/reactor_data.hpp>

{% call utils.optional_namespace(proto.namespace) %}
{% for service in proto.services %}

namespace {

class {{service.name}}Reactor final :
    public USERVER_NAMESPACE::ugrpc::server::Reactor {
 public:
  {{service.name}}Reactor(
      std::unique_ptr<{{service.name}}HandlerBase> handler,
      ::grpc::ServerCompletionQueue& queue,
      USERVER_NAMESPACE::engine::TaskProcessor& handler_task_processor)
      : data_(std::move(handler), queue, handler_task_processor) {}

  ::grpc::Service& GetService() override { return data_.GetStub(); }

  void Start() override {
    using Stub = {{service.name}}::AsyncService;
    using Handler = {{service.name}}HandlerBase;

    {% for method in service.method %}
    USERVER_NAMESPACE::ugrpc::server::impl::ListenAsync(
        data_, "{{service.name}}::{{method.name}}",
        &Stub::Request{{method.name}}, &Handler::{{method.name}});
    {% endfor %}
  }

 private:
  USERVER_NAMESPACE::ugrpc::server::impl::ReactorData<{{service.name}}HandlerBase> data_;
};

}  // namespace

{{service.name}}HandlerBase::~{{service.name}}HandlerBase() = default;

std::unique_ptr<USERVER_NAMESPACE::ugrpc::server::Reactor>
{{service.name}}HandlerBase::MakeReactor(
    std::unique_ptr<{{service.name}}HandlerBase> handler,
    ::grpc::ServerCompletionQueue& queue,
    USERVER_NAMESPACE::engine::TaskProcessor& handler_task_processor) {
  return std::make_unique<{{service.name}}Reactor>(
              std::move(handler), queue, handler_task_processor);
}
{% for method in service.method %}

void {{service.name}}HandlerBase::{{method.name}}(
    {% if method.client_streaming %}
    {{method.name}}Call& call) {
  {% else %}
    {{method.name}}Call& call,
    [[maybe_unused]] {{ method.input_type | grpc_to_cpp_name }}&& request) {
  {% endif %}
  call.FinishWithError(USERVER_NAMESPACE::ugrpc::server::impl::kUnimplementedStatus);
}
{% endfor %}
{% endfor %}
{% endcall %} {# utils.optional_namespace #}
