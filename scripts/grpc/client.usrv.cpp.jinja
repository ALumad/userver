{% import "utils.inc.jinja" as utils %}
{{- utils.do_not_edit() }}
// This file was generated from {{ proto.source_file }}
#include "{{ proto.source_file_without_ext }}_client.usrv.pb.hpp"

#include <utility>

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-parameter"
#include "{{ proto.source_file_without_ext }}.grpc.pb.h"
#pragma clang diagnostic pop

{% call utils.optional_namespace(proto.namespace) %}
{% for service in proto.services %}

{{service.name}}Client::{{service.name}}Client(
    const std::shared_ptr<::grpc::Channel>& channel,
    ::grpc::CompletionQueue& queue)
    : impl_(channel, queue, std::in_place_type<{{service.name}}>) {}

{{service.name}}Client::{{service.name}}Client(
    USERVER_NAMESPACE::ugrpc::client::impl::ChannelCache::Token&& channel_token,
    ::grpc::CompletionQueue& queue)
    : impl_(std::move(channel_token), queue, std::in_place_type<{{service.name}}>) {}
  {% for method in service.method %}

{{service.name}}Client::{{method.name}}Call
{{service.name}}Client::{{method.name}}(
    {% if not method.client_streaming %}
    const {{ method.input_type | grpc_to_cpp_name }}& request,
    {% endif %}
    std::unique_ptr<::grpc::ClientContext> context) {
  return {impl_.GetStub<{{service.name}}>(), impl_.GetQueue(),
          &{{service.name}}::Stub::PrepareAsync{{method.name}},
          "{{service.name}}::{{method.name}}",
          {% if method.client_streaming %}
          std::move(context)};
  {% else %}
  std::move(context), request};
{% endif %}
}
  {% endfor %}
{% endfor %}
{% endcall %} {# utils.optional_namespace #}
