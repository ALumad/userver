#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import requests, re, sys, codecs, argparse

reload(sys)
sys.setdefaultencoding('utf-8')
sys.stdout = codecs.getwriter('utf8')(sys.stdout)
sys.stderr = codecs.getwriter('utf8')(sys.stderr)

parser = argparse.ArgumentParser(description = "SqlCode enum generator")
parser.add_argument("-o", "--header", help="Outuput header", metavar="out.hpp")
parser.add_argument("-s", "--source", help="Outuput source", metavar="out.cpp")
parser.add_argument("-t", "--test", help="Generate test", metavar="test.cpp")

args = parser.parse_args()

log_stream = sys.stderr

err_codes_page = "https://www.postgresql.org/docs/10/static/errcodes-appendix.html"
regex = ur"(?:class=\"bold\"[\S]*>([^<]+))|(?:class=\"literal\">([^<]+).*?class=.*?\"symbol\">([^<]+))"

DEF_OFFSET = "  "
LIT_OFFSET = "  "

error_class = None
CLASSES_ENUM = u'''
// PostgreSQL error classes
/// Docs: https://www.postgresql.org/docs/10/static/errcodes-appendix.html
/// Enumeration was generated by userver/scripts/postgres/pg_sql_codes.py
enum class SqlStateClass : std::int64_t {'''
ERRORS_ENUM = u'''
/// PostgreSQL error codes
/// Docs: https://www.postgresql.org/docs/10/static/errcodes-appendix.html
/// Enumeration was generated by userver/scripts/postgres/pg_sql_codes.py
enum class SqlState : std::int64_t {
  kUnknownState, ///!< Unknown state, not in PostgreSQL docs'''
ERROR_LITERALS = u'''
// This goes to the cpp file in an anonimous namespace
// Data was generated by userver/scripts/postgres/pg_sql_codes.py
// TODO Replace with a string_view
const std::unordered_map<std::string, SqlState> kCodeStrToState{'''

DISAMBIGUATION = {
  'kWarning': 'Warn',
  'kExternalRoutineException' : 'Ex',
  'kExternalRoutineInvocationException' : 'Ex'
}

def static_vars(**kwargs):
    def decorate(func):
        for k in kwargs:
            setattr(func, k, kwargs[k])
        return func
    return decorate

@static_vars(value=0)
def class_value(prev_count):
  if (class_value.value == 0):
    class_value.value = 1
  else:
    val = class_value.value * 2
    while class_value.value + prev_count > val:
      val *= 2
    class_value.value = val
  return class_value.value

def to_camel_case(snake_str):
  components = snake_str.split('_')
  return 'k' + ''.join(x.title() for x in components)

def print_with_offset(stream, offset, *args):
  lines = "\n".join(args).split("\n")
  print >> stream, offset + ("\n" + offset).join(lines)

class ErrorClass:
  errors = {}
  class ErrorCode:
    def __init__(self, klass, symbol, literal):
      self.klass = klass
      self.symbol = symbol
      self.literal = literal
    
    def disambiguated_symbol(self):
      da = ""
      if ErrorClass.errors[self.symbol] > 1:
        if DISAMBIGUATION.has_key(self.klass):
          da = DISAMBIGUATION[self.klass]
      return self.symbol + da
    
    def print_decl(self, stream):
      if self.symbol == self.klass:
        print_with_offset(stream, DEF_OFFSET, u"{symbol} = static_cast<std::int64_t>(SqlStateClass::{symbol}), //!< {literal}".format(symbol = self.disambiguated_symbol(), literal = self.literal))
      else:
        print_with_offset(stream, DEF_OFFSET, u"{symbol}, //!< {literal}".format(symbol = self.disambiguated_symbol(), literal = self.literal))
    
    def print_literal(self, stream):
      print_with_offset(stream, LIT_OFFSET, u'{"' + self.literal + '", SqlState::' + self.disambiguated_symbol() + '},')
      
    def print_class_test(self, stream):
      print_with_offset(stream, LIT_OFFSET, u"EXPECT_EQ(pg::SqlStateClass::{klass}, pg::GetSqlStateClass(pg::SqlState::{symbol}));".format(klass=self.klass, symbol=self.disambiguated_symbol()))
  
    def print_parse_test(self, stream):
      print_with_offset(stream, LIT_OFFSET, u'EXPECT_EQ(pg::SqlState::{symbol}, pg::SqlStateFromString("{literal}"));'.format(symbol=self.disambiguated_symbol(), literal=self.literal))
      
  def __init__(self, desc, prev_count):
    self.desc = desc
    self.value = class_value(prev_count)
    self.errors = []
    self.name = None

  def add_error(self, symbol, literal):
    if self.name == None:
      self.name = symbol
    self.errors.append(ErrorClass.ErrorCode(self.name, symbol, literal))
    if ErrorClass.errors.has_key(symbol):
      ErrorClass.errors[symbol] += 1
    else:
      ErrorClass.errors[symbol] = 1

  def print_class(self, stream):
    print_with_offset(stream, DEF_OFFSET, u"{name} = 0x{value:02x},".format(name=self.name, value=self.value))
  
  def print_symbols(self, stream):
    print_with_offset(stream, DEF_OFFSET, "//@{", u"/** @name {desc} */".format(desc = self.desc))
    for ec in self.errors:
      ec.print_decl(stream)
    print_with_offset(stream, DEF_OFFSET, "//@}")

  def print_literals(self, stream):
    print_with_offset(stream, LIT_OFFSET, "//@{", u"/** @name {desc} */".format(desc = self.desc))
    for ec in self.errors:
      ec.print_literal(stream)
    print_with_offset(stream, LIT_OFFSET, "//@}")

  def print_test(self, stream):
    print_with_offset(stream, LIT_OFFSET, u"// {desc}".format(desc = self.desc))
    for ec in self.errors:
      ec.print_parse_test(stream)
      ec.print_class_test(stream)
    

print >> log_stream, "Retrieving documentation"
page = requests.get(err_codes_page)
print >> log_stream, "Cleaning html"
page_text = re.sub(ur".*?<table[^>]+summary=\"PostgreSQL Error Codes\"[^>]*>", "", page.text, flags= re.MULTILINE | re.DOTALL)
page_text = re.sub(ur"</table>.*", "", page_text, flags= re.MULTILINE | re.DOTALL)

print >> log_stream, "Parsing html"
matches = re.finditer(regex, page_text, re.MULTILINE | re.DOTALL)

err_count = 0
current_class = None
error_classes = []

print >> log_stream, "Collecting definitions"
for matchNum, match in enumerate(matches):
  matchNum = matchNum + 1
  
  if match.group(1):
    class_desc = match.group(1).replace("\n", " ")
    current_class = ErrorClass(class_desc, err_count)
    error_classes.append(current_class)
    err_count = 0
  elif match.group(2):
    literal = match.group(2)
    symbol = to_camel_case(match.group(3))
    current_class.add_error(symbol, literal)
    err_count += 1

print >> log_stream, "Printing sources"
header = sys.stdout
if args.header:
  header = open(args.header, 'w')
source = sys.stdout
if args.source:
  source = open(args.source, 'w')

print >> header, CLASSES_ENUM
for ec in error_classes:
  ec.print_class(header)
print >> header, "};\n\n"

print >> header, ERRORS_ENUM
for ec in error_classes:
  ec.print_symbols(header)
print >> header, "};\n"

print >> source, ERROR_LITERALS
for ec in error_classes:
  ec.print_literals(source)
print >> source, "};\n"

if args.test:
  os = open(args.test, 'w')
  print >> os, "// Test was generated by userver/scripts/postgres/pg_sql_codes.py"
  print >> os, "TEST(PostgreError, SqlState) {";
  for ec in error_classes:
    ec.print_test(os)
  print >> os, "}\n"

print >> log_stream, "Done"
